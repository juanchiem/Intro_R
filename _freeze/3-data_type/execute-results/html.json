{
  "hash": "0674e8b754c73b27910361744d28d48f",
  "result": {
    "markdown": "# Tipos de datos\n\n\n\n\n\nEn términos genéricos, todos los elementos que maneja R se consideran objetos: un valor numérico, un vector, una función, una base de datos, un gráfico, todos son *objetos*.\n\nUno de los típicos errores que se nos presenta al usar R es el mal uso de las distintas clases de objetos que manipulamos en nuestras sesiones de trabajo.\n\nPara un procesamiento correcto, un lenguaje de programación debe saber qué se puede y qué no se puede hacer con un valor en particular. Por ejemplo, no se pueden hacer operaciones matemáticas con las palabras \"hola\" y \"mundo\". Del mismo modo, no puede cambiar los números 1 y -34.5 de minúsculas a mayúsculas. Debido a esto, R tiene una característica llamada tipos de datos.\n\nPrincipales tipos de datos que vamos a usar:\n\n\n::: {.cell hash='3-data_type_cache/html/data_types_3c337596adc903e01869af158de80d24'}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table\" style=\"font-size: 15px; width: auto !important; margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Clase </th>\n   <th style=\"text-align:left;\"> Ejemplo </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> numérico </td>\n   <td style=\"text-align:left;\"> 12.3, 5, 999 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> caracter </td>\n   <td style=\"text-align:left;\"> hola, JUAN </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> lógica </td>\n   <td style=\"text-align:left;\"> TRUE, FALSE </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> fecha </td>\n   <td style=\"text-align:left;\"> 2021-05-06 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n## Vectores\n\nLa unidad básica de datos en R es un vector, los cuales pueden ser de diferentes clases. Los que más usaremos son las siguientes clases.\n\n`vector <- c(Concatenación, de, elementos, atómicos)`\n\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-1_3611b5989cff68fc831c02e9eb31cb6e'}\n\n```{.r .cell-code}\nraices_largo <- c(8.5, 9, 11)\n```\n:::\n\n\nHay muchas funciones que nos permiten inspeccionar los datos. Una muy versatil es `str()`\n\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-2_38adb89761060789020f1567f29f0ffb'}\n\n```{.r .cell-code}\nstr(raices_largo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n num [1:3] 8.5 9 11\n```\n:::\n\n```{.r .cell-code}\nlength(raices_largo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\nSupongamos que \"raices_largo\" es una muestra de la variable largo de raiz de trigo en cm y nos interesaria algunas métricas\n\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-3_aba2f3d4d849567d0f15f9ecae76193c'}\n\n```{.r .cell-code}\nsummary(raices_largo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   8.50    8.75    9.00    9.50   10.00   11.00 \n```\n:::\n:::\n\n\n...descomponiendo ´summary´\n\n-   Medidas de posición\n\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-4_c48c730fcd08a859735562459fd02f69'}\n\n```{.r .cell-code}\nmean(raices_largo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 9.5\n```\n:::\n\n```{.r .cell-code}\nmedian(raices_largo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 9\n```\n:::\n\n```{.r .cell-code}\nquantile(raices_largo, 0.25)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n 25% \n8.75 \n```\n:::\n:::\n\n\n-   Medidas de dispersión\n\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-5_a53bac5616efab4d6a59e3f43911c549'}\n\n```{.r .cell-code}\nmin(raices_largo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8.5\n```\n:::\n\n```{.r .cell-code}\nmax(raices_largo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 11\n```\n:::\n\n```{.r .cell-code}\nrange(raices_largo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  8.5 11.0\n```\n:::\n:::\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-6_9074f48f6414162d64588c9930a1bc58'}\n\n```{.r .cell-code}\nvar(raices_largo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.75\n```\n:::\n\n```{.r .cell-code}\nsd(raices_largo) # sqrt(var(raices_largo))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.322876\n```\n:::\n:::\n\n\n[Coeficiente de variación](https://es.wikipedia.org/wiki/Coeficiente_de_variaci%C3%B3n)\n\nEn estadística, cuando se desea hacer referencia a la relación entre el tamaño de la media y la variabilidad de la variable, se utiliza el coeficiente de variación (suele representarse por las siglas \"C.V.\"). Es adimensional, o sea no tiene unidades y suele expresarse en %.\n\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-7_922f7172f31aac5be1493305b6a18c7f'}\n\n```{.r .cell-code}\ncv <- sd(raices_largo) / mean(raices_largo) * 100\ncv\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 13.92501\n```\n:::\n:::\n\nAhora, imaginemos que el \"cv\" es una función que usaremos a diario en nuestro trabajo. Por lo tanto quisiéramos tenerla mas \"a mano\" para usarla en cualquier momento. \n\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-8_b1fbda09950c24119d12dec1d60091fa'}\n\n```{.r .cell-code}\ncv <- function(x){\n  sd(x)/mean(x)*100\n}\n\nraices_largo <- c(8.5, 9, 11)\ncv(raices_largo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 13.92501\n```\n:::\n:::\n\nAhora bien, supongamos que queremos tener esta función (y muchas otras mas, de mayor complejidad incluso) disponibles desde el inicio de nuestra sesión de trabajo... \nDeberíamos \"empaquetar\" todas esas funciones y llamarlas con un breve código. \n\n\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-9_b0b021c2c0e5e55c8da0e6cf1ed7f406'}\n\n```{.r .cell-code}\nsource(\"my_fun.R\")\n```\n:::\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-10_128a15d74fa7c476ef053518562bf646'}\n\n```{.r .cell-code}\nraices_largo - 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  7.5  8.0 10.0\n```\n:::\n\n```{.r .cell-code}\nsum(raices_largo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 28.5\n```\n:::\n\n```{.r .cell-code}\ncumsum(raices_largo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  8.5 17.5 28.5\n```\n:::\n:::\n\n## Caracter {.unnumbered}\n\nAlmacena valores de \"caracteres\" o \"cadenas\" (en inglés \"string\"): pueden contener letras, números y símbolos. La forma más sencilla de indicar que un valor es de tipo carácter es colocar el valor entre comillas simples o dobles.\n\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-11_69d92b3b9fbfe517a6fe16a6eb380f76'}\n\n```{.r .cell-code}\nvec_car <- c(\"Hola mundo\", \"2022-20-04\", '2022')   \nstr(vec_car)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n chr [1:3] \"Hola mundo\" \"2022-20-04\" \"2022\"\n```\n:::\n:::\n\n\n## Lógicos {.unnumbered}\n\nEl tipo de dato lógico o booleano es en computación aquel que puede representar valores de lógica binaria, esto es 2 valores: falso o verdadero\n\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-12_19bd446b1bd354b40bb3341e01014500'}\n\n```{.r .cell-code}\nvec_logi <- c(FALSE, TRUE, F, T) # logi <- false\nstr(vec_logi)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n logi [1:4] FALSE TRUE FALSE TRUE\n```\n:::\n:::\n\n\n## Fechas {.unnumbered}\n\n-   El formato default es yyyy-mm-dd\n\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-13_09b9c24d4b129417e9c5e29de566aa39'}\n\n```{.r .cell-code}\nvec_fechas <- as.Date(c(\"2007-06-22\", \"2004-02-13\"))\nstr(vec_fechas)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Date[1:2], format: \"2007-06-22\" \"2004-02-13\"\n```\n:::\n\n```{.r .cell-code}\nvec_fechas - 1 \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2007-06-21\" \"2004-02-12\"\n```\n:::\n:::\n\n\n::: {#box1 .blue-box}\n-   Nosotros comunmente usamos 'dd/mm/yyyy'? debemos convertir:\n\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-14_a327989da310c0c50f99b00776e9865d'}\n\n```{.r .cell-code}\nvec_fechas2 <- c(\"01/06/2020\", \"31/12/2020\")\nstr(vec_fechas2) # son caracteres!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n chr [1:2] \"01/06/2020\" \"31/12/2020\"\n```\n:::\n\n```{.r .cell-code}\nvec_fechas3 <- as.Date(vec_fechas2, \"%d/%m/%Y\") # con paquete base\nstr(vec_fechas3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Date[1:2], format: \"2020-06-01\" \"2020-12-31\"\n```\n:::\n\n```{.r .cell-code}\nvec_fechas4 <- lubridate::dmy(vec_fechas2) # con lubridate!\nstr(vec_fechas4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Date[1:2], format: \"2020-06-01\" \"2020-12-31\"\n```\n:::\n\n```{.r .cell-code}\ndiff(vec_fechas4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime difference of 213 days\n```\n:::\n:::\n\n:::\n\n::: blue-box\n-   Forzando las clases explícitamente\n\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-15_81e6792523a8366c1fae0ccba00a374d'}\n\n```{.r .cell-code}\nraices_car <- as.character(raices_largo)\nstr(raices_car)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n chr [1:3] \"8.5\" \"9\" \"11\"\n```\n:::\n:::\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-16_7f992101668f5f5267ef53b6c56498e2'}\n\n```{.r .cell-code}\nvec_logi2 <- as.logical(c(0,1))\nvec_logi2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE\n```\n:::\n:::\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-17_ee1d843758c9deb9afa363f59afe39c3'}\n\n```{.r .cell-code}\nvec_logi_num <- as.numeric(vec_logi)\nvec_logi_num\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 1 0 1\n```\n:::\n:::\n\n\n-   Existe una jerarquia a la hora de R tener que decidir de qué tipo de vector se trata (\"piedra, papel o tijera\")\n\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-18_609406c04684a16337759ca63c1b255d'}\n\n```{.r .cell-code}\ny1 <- c(1.7, \"a\")  ## character\nstr(y1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n chr [1:2] \"1.7\" \"a\"\n```\n:::\n\n```{.r .cell-code}\ny2 <- c(TRUE, \"a\") ## character\nstr(y2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n chr [1:2] \"TRUE\" \"a\"\n```\n:::\n\n```{.r .cell-code}\ny3 <- c(TRUE, 0, 10)   ## numeric\nstr(y3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n num [1:3] 1 0 10\n```\n:::\n:::\n\n:::\n\n## Datos faltantes\n\nSe representan con un `NA`, para cualquier tipo de datos\n\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-19_cf27af46f271db853a00fc9613f6fb0a'}\n\n```{.r .cell-code}\nvec_num <- c(1, 5, NA)\nstr(vec_num)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n num [1:3] 1 5 NA\n```\n:::\n\n```{.r .cell-code}\nlength(vec_num)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\n## Factores\n\nEn R las variables categóricas se almacenan como **factores** tanto sea para vectores que contienen caracteres o numéros. Uno de los usos más importantes de los factores es en el modelado estadístico, asumiendo un rol de variable categorica, diferente de las variables contínuas. Claro ejemplo de factores son los tratamientos, por ej: genotipos, bloques, etc.\n\nA diferencia de los vectores vistos anteriormente, todo factor tiene sus niveles (`levels`), que por default se ordenan alfabéticamente.\n\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-20_355fbb333eee7c36dbfe3bff123557a5'}\n\n```{.r .cell-code}\ngeno <- c(\"control\", \"B35\", \"A12\", \"control\", \"A12\", \"B35\", \"A12\", \"B35\", \"control\")\nstr(geno)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n chr [1:9] \"control\" \"B35\" \"A12\" \"control\" \"A12\" \"B35\" \"A12\" \"B35\" ...\n```\n:::\n\n```{.r .cell-code}\nlevels(geno)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n\n```{.r .cell-code}\ngeno_f <- factor(geno)\nstr(geno_f)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Factor w/ 3 levels \"A12\",\"B35\",\"control\": 3 2 1 3 1 2 1 2 3\n```\n:::\n:::\n\n\n## Secuencias\n\n### Numéricas {.unnumbered}\n\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-21_1ac384ab3c62edb747c74a3aeec03782'}\n\n```{.r .cell-code}\n1:7  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5 6 7\n```\n:::\n\n```{.r .cell-code}\nseq(from = 0, to = 20, #by=2) # \n    length=4) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  0.000000  6.666667 13.333333 20.000000\n```\n:::\n\n```{.r .cell-code}\nrep(1:3, times=3) #  , each=3   \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 1 2 3 1 2 3\n```\n:::\n:::\n\n\n### Letras {.unnumbered}\n\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-22_d462b66d31296ac0ebdb61adba124b23'}\n\n```{.r .cell-code}\nLETTERS  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n```\n:::\n\n```{.r .cell-code}\nrep(c(\"a\",\"b\", \"c\"), times=3) #  , each=3   \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"b\" \"c\" \"a\" \"b\" \"c\" \"a\" \"b\" \"c\"\n```\n:::\n:::\n\n\n### Fechas {.unnumbered}\n\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-23_5a006b01fe6e279af57ef43b9b28694b'}\n\n```{.r .cell-code}\nseq(as.Date(\"2015-01-15\"), as.Date(\"2015-12-15\"), \"1 month\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"2015-01-15\" \"2015-02-15\" \"2015-03-15\" \"2015-04-15\" \"2015-05-15\"\n [6] \"2015-06-15\" \"2015-07-15\" \"2015-08-15\" \"2015-09-15\" \"2015-10-15\"\n[11] \"2015-11-15\" \"2015-12-15\"\n```\n:::\n:::\n\n\n## Números aleatorios\n\nLa generación de números aleatorios es en muchas ocasiones un requerimiento esencial en investigación científica. Proceder de este modo puede reducir cualquier sesgo generado por nuestra persona a la hora de seleccionar una muestra, o aplicar un tratamiento a una unidad experimental.\n\n-   Generar números enteros de modo aleatorio de una muestra determinada\n\n`sample()`\n\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-24_bf0e4c1a8dd1d83af3a07b6aaccf0953'}\n\n```{.r .cell-code}\nset.seed(123)\nsample(1:30, size=10, replace=F) #sin reposición\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 15 19 14  3 10 18 22 11  5 20\n```\n:::\n:::\n\n\n-   Generar números aleatorios de una distribución específica de parámetros conocidos:\n\n`runif()` - números racionales aleatoriamente, uniformemente distribuidos en un intervalo\n\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-25_9606757332bf742a82aae52fc0f44c32'}\n\n```{.r .cell-code}\nnum_unif <- runif(100, min=3, max=4)\nhist(num_unif)\n```\n\n::: {.cell-output-display}\n![](3-data_type_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n`rnorm()` - números aleatorios, pertenecientes a una población con [distribución normal](https://en.wikipedia.org/wiki/68%E2%80%9395%E2%80%9399.7_rule), con parámetros μ y σ.\n\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-26_c266d936e467d7a1349d7a6af4e454ce'}\n\n```{.r .cell-code}\nnum_norm <- rnorm(100, mean=70, sd=5) \nhist(num_norm)\n```\n\n::: {.cell-output-display}\n![](3-data_type_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n## Valores especiales\n\nExisten valores reservados para representar datos faltantes, infinitos, e indefiniciones matemáticas.\n\n-   NA (Not Available) significa dato faltante/indisponible. El NA tiene una clase, o sea, pueden ser NA numeric, NA character, etc.\n\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-27_a64d50fd537a77726a94d85eeaf9e697'}\n\n```{.r .cell-code}\ny <- c(2, 4, NA, 6)\nis.na(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE FALSE\n```\n:::\n:::\n\n\n> Calcule el promedio de y (use la ayuda de R en caso necesario)`mean(y)`\n\n-   NaN (Not a Number) es el resultado de una operación matemática inválida, ej: 0/0 y log(-1). Un NaN es un NA, pero no recíprocamente.\n\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-28_f6de0fe39c0d27a81e417684d3eca38f'}\n\n```{.r .cell-code}\n0/0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NaN\n```\n:::\n\n```{.r .cell-code}\nis.nan(0/0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.na(0/0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n-   `NULL` es el vacío de R. Es como si el objeto no existiese\n\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-29_202eb70d04ffd90bfc140d55f01fa754'}\n\n```{.r .cell-code}\na = NULL\na\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n:::\n\n\n-   `Inf` (infinito). Es el resultado de operaciones matemáticas cuyo límite es infinito, es decir, es un número muy grande, por ejemplo, 1/0 o 10\\^310. Acepta signo negativo -Inf.\n\n\n::: {.cell hash='3-data_type_cache/html/unnamed-chunk-30_a4b9e2abfc82f81a3da1ebeee463ac1c'}\n\n```{.r .cell-code}\n1/0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Inf\n```\n:::\n\n```{.r .cell-code}\n1/Inf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/kePrint-0.0.1/kePrint.js\"></script>\r\n<link href=\"site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}